# Android-Pentest-CheatSheet

# Device Rooting
https://github.com/newbit1/rootAVD




# Network Traffic Analysis
<i>HINT: You will need ProxyDroid installed on a physical device or an emulator (based on an ARM system image) using the –http-proxy command line option.</i>
To be able to inspect network traffic deriving from the Uber application, we recommend using a rooted device with ProxyDroid installed or launching an emulator (based on an ARM system image) using the –http-proxy command line option.

## adb (Android Debug Bridge)

List Devices/Emulators
```
adb devices
```

Open shell on Device
```
adb shell
```

Installing APK file
```
adb install filename.apk
```

Switch off device
```
adb -s <emulator-number> emu kill
```


Call ACTION
```
adb.exe shell am start –a android.intent.action.MAIN –n com.example.android.notepad/.NotesList
```
- ACTION: android.intent.action.MAIN
- PACKAGE: com.example.android.notepad
- ACTIVITY: .NotesList 

Send to Content Provider
```
adb.exe shell am start –a android.intent.action.EDIT –n com.example.android.notepad/.NoteEditor –d content://com.google.provider.NotePad/notes/1
```
- The –d option specifies the DATA_URI to send. Its structure:
 - Scheme: `content://`
 - Authority: `com.google.provider.NotePad`
 - Path: `/notes/`
 - ID: `1`



## SSL Vulnerabilities

HostNameVerifier is implemented inside the application as follows, and will turn off any kind of hostname verification when using SSL connections.
```
 SSLSocketFactory sf = new CustomSSLSocketFactory(trustStore);
 sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
```

Accepting Any Certificate
```
public void onReceivedSslError(WebView paramWebView, SslErrorHandler paramSslErrorHandler, SslError paramSslError)
{
  AuthorizationRequest.OAuthDialog.this.setLiveSdkProvProgressStatus(false);
  paramSslErrorHandler.proceed();
}
```
The custom SSL error handler above ignores any certificate validation error. Specifically, the handler will call proceed() and a connection will always be established regardless of any certificate error occurring. This leads to the application accepting any certificate.


## Certificate Pinning
through **.smali** files patching

https://github.com/moxie0/AndroidPinning

https://github.com/newbit1/rootAVD

https://github.com/ikust/hello-pinnedcerts

NOTE: If you intend to install the rebuilt APK in an emulator other than the one of Android
Studio or in a physical device, do not forget to sign your application.

For more information on signing the rebuilt APK please refer to
https://developer.android.com/studio/publish/app-signing.html.


HttpClientBuilder class is called to construct the DefaultHttpClient

From the arguments that DefaultHttpClient expects during creation, you can see that it takes a keyStore into consideration. Specifically, when creating an instance of DefaultHttpClient that keyStore can be used to pin the certificates that it contains, by adding a scheme. This will result in the constructed httpClient, only allowing requests to hosts that are signed with the certificates provided in keyStore file.

Certificate pinning is usually implemented by comparing the certificate the application comes across during connection, against a predefined and bundled list of trusted SSL certificates, within the application (in this case, the trusted SSL certificates are inside a BKS keystore).

In order to bypass the certificate pinning mechanism, you will have to find a way to “remove” the DefaultHttpClient parameter which is related to the keyStore. But this is not the only place where certificate pinning related code exists.

If you navigate to `/res/raw/` directory of Apktool’s output, you will find the Bouncy Castle keystore that the application uses.

You will have to “remove” pinCertificates as its functionality is highly related with the keyStore that facilitates the certificate pinning mechanism’s implementation.

As you identified, all the source code components you have to “remove” in order to bypass the certificate pinning mechanism are located inside the HttpClientBuilder class. The easiest way to “remove” application components is by patching the class that contains them. You can patch a class by modifying/editing the related application’s .smali files.

Finally, all you have to do is rebuild the application using Apktool and sign it using the *jarsigner* tool.

# LFI (Local File Inclusion)

# Content Provider
Content provider is explicitly exported. This means that it can be accessed and used by any application on the device.


